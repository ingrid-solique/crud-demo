<script>
  /**
   * CRUD Mixin for the entity editor.
   *
   * When available, it uses a `vaadin-confirm-dialog`, otherwise it
   * downgrades to `window.confirm`.
   *
   * @polymerMixin
   */
  window.CrudItemMixin = subclass => class extends subclass {
    static get properties() {
      return {
        /**
         * The entity being edited.
         */
        item: Object,
        /**
         * `true` when the entity has been modified.
         */
        dirty: Boolean,
        /**
         * `true` if it is editing a new entity.
         */
        new: Boolean,

        /** @private */
        _dialog: Element,
        /** @private */
        deleteCaption: {
          value: 'Confirm Delete Item'
        },
        /** @private */
        deleteMessage: {
          value: 'Are you sure you want to delete the selected Item?. This action cannot be undone.'
        },
        /** @private */
        deleteOkText: {
          value: 'Delete'
        },
        /** @private */
        deleteCancelText: {
          value: 'Cancel'
        },
        /** @private */
        unsavedCaption: {
          value: 'Unsaved Changes'
        },
        /** @private */
        unsavedMessage: {
          value: 'There are unsave modifications to the Item. Are you sure to cancel the edition.'
        },
        /** @private */
        unsavedOkText: {
          value: 'Yes'
        },
        /** @private */
        unsavedCancelText: {
          value: 'Back'
        }
      };
    }

    static get observers() {
      return [
        '_onItemChanged(item)',
        '_checkDirty(item.*)'
      ];
    }

    ready() {
      super.ready();
      Polymer.RenderStatus.afterNextRender(this, () => {
        this._dialog = document.createElement('vaadin-confirm-dialog');
        document.body.appendChild(this._dialog);

        // If this is in a vaadin-dialog, it sends a before-close event
        this.parentNode.addEventListener('before-close', e => {
          this.dirty && e.preventDefault();
        });
      });
    }

    _onItemChanged() {
      if (!this._itemLock) {
        this.dirty = false;
        this.new = !this.item || Object.keys(this.item).length < 1;
        this._originalItemString = JSON.stringify(this.item);

        // We reuse item name wich is more meaningful in declarative
        this._itemLock = true;
        this.item = Object.assign({}, this.item);
        this._itemLock = undefined;
      }
    }

    _checkDirty() {
      this.dirty = this.item && Object.keys(this.item).length > 0
        && JSON.stringify(this.item) != this._originalItemString;
    }


    /**
     * Sends up a `close` event, but previously it checks for the `dirty` flag
     * asking the user for confirmation.
     */
    cancel() {
      if (this.dirty) {
        this._confirm(() => this.close(true),
          this.unsavedCaption, this.unsavedMessage, this.unsavedOkText, this.unsavedCancelText);
      } else {
        this.close();
      }
    }

    /**
     * Sends up a `close` event. If `force == true` it also unsets the dirty flag.
     */
    close(force) {
      // if forced set dirty to true to avoid preventing close on before-close phase
      this.dirty = !force && this.dirty;
      this.dispatchEvent(new CustomEvent('close', {bubbles: true, composed: true}));
    }

    /**
     * First it Checks that all form elements are valid, then it sends up a `save`
     * event with the edited item as the detail.
     */
    save() {
      if (this.valid = Array.prototype.reduce.call(this.root.querySelectorAll('*'), (prev, elm) => {
        return (elm.validate ? elm.validate() : elm.checkValidity ? elm.checkValidity() : true) && prev;
      }, true)) {
        this.dispatchEvent(new CustomEvent('save', {bubbles: true, composed: true, detail: this.item}));
        this.close(true);
      }
    }

    /**
     * Sends up a `delete` event with the edited item as the detail.
     */
    delete() {
      this._confirm(() => {
        this.dispatchEvent(new CustomEvent('delete', {bubbles: true, composed: true, detail: this.item}));
        this.close(true);
      }, this.deleteCaption, this.deleteMessage, this.deleteOkText, this.deleteCancelText);
    }

    _confirm(callback, caption, message, okText, cancelText) {
      if (this._dialog.root) { // vaadin-confirm-dialog is imported
        this._dialog.callback = callback;
        this._dialog.caption = caption;
        this._dialog.message = message;
        this._dialog.okText = okText;
        this._dialog.cancelText = cancelText;
        this._dialog.opened = true;
      } else { // fallback to window.confirm.
        if (window.confirm(message)) {
          callback();
        }
      }
    }
  };
</script>
